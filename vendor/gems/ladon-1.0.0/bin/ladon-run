#!/usr/bin/env ruby

require 'optparse'
require 'pathname'
require 'pp'
require 'pry'
require 'ladon'

# FIXME: eventually we should model Ladon in Ladon and use ModelAutomation here
class LadonAutomationRunner < Ladon::Automator::Automation
  ARGV_FLAG = :argv
  RIDICULOUS_BANNER =
    " _           _
| | __ _  __| | ___  _ __            _ __ _   _ _ __  _ __   ___ _ __
| |/ _` |/ _` |/ _ \\| '_ \\   _____  | '__| | | | '_ \\| '_ \\ / _ \\ '__|
| | (_| | (_| | (_) | | | | |_____| | |  | |_| | | | | | | |  __/ |
|_|\\__,_|\\__,_|\\___/|_| |_|         |_|   \\__,_|_| |_|_| |_|\\___|_|   ".freeze
  AUTOMATION_DIR_BASENAME = 'automations'.freeze

  def setup
    argv_given = flags.get(ARGV_FLAG, default_to: nil)
    halting_assert('ARGV flag must be provided') do
      argv_given.is_a?(Array)
    end

    halting_assert('Options provided must be valid') do
      @options = _parse_options(flags: argv_given)
      _validate_options?
    end

    _include_load_path

    halting_assert('Must be able to load a file at the specified path') do
      _load_automation_source
    end

    @target_automation_class = _select_automation_class
  end

  def execute
    _print_separator_line
    puts RIDICULOUS_BANNER
    _print_separator_line

    puts "\nStarting: #{@target_automation_class.name}"
    @target_automation = @target_automation_class.spawn(flags: @options.flags)

    @target_automation_class.all_phases.each_with_index do |phase_name, idx|
      _go_interactive if @options.interactive_before.include?(phase_name)

      print "Beginning phase: #{phase_name}..."
      @target_automation.run(to_index: idx) # this is the interesting line
      puts 'complete!'

      _go_interactive if @options.interactive_post.include?(phase_name)
    end
    puts "\nExecution complete"
  end

  def teardown
    _go_interactive if @options.nil? || @options.review

    puts "Result: #{@target_automation.result.status}"
    _print_log_entries if @target_automation.result.error?
  end

  # If there was a failure in setup, don't run execute.
  def skip_reason(phase)
    return "Failure detected in #{SETUP_PHASE}" if phase == EXECUTE_PHASE && !@result.success?
    super
  end

  private

  def _print_log_entries
    return if @target_automation.result.logger.entries.empty?
    puts ''
    _print_separator_line('-')
    pp(@target_automation.result.logger.entries)
    _print_separator_line('-')
    puts ''
  end

  def _go_interactive
    puts ''
    _print_separator_line('-')
    puts "\tStarting interactive mode\n"

    binding.pry

    puts "\n\tInteractive mode exited, continuing..."
    _print_separator_line('-')
    puts ''
  end

  def _parse_options(flags: [])
    vals = Struct.new(:automation_path,
                      :automation_class_name,
                      :interactive_before,
                      :interactive_post,
                      :review,
                      :flags).new
    OptionParser.new do |opts|
      opts.banner = 'Usage: ladon-run [options]'

      opts.on('-a PATH',
              '--automation PATH',
              String,
              '[REQUIRED] Path to the automation script to be executed') do |val|
        vals.automation_path = val
      end

      opts.on('-s NAME',
              '--automation_class NAME',
              String,
              'Name of the Automation class to run.') do |val|
        vals.automation_class_name = val
      end

      opts.on('-b PHASE_LIST',
              '--interactive_before PHASE_LIST',
              String,
              'Comma-separated list of phases to enter interactive mode BEFORE running') do |val|
        vals.interactive_before = val.split(',').map { |phase| phase.strip.to_sym }
      end

      opts.on('-p PHASE_LIST',
              '--interactive_post PHASE_LIST',
              String,
              'Comma-separated list of phases to enter interactive mode AFTER running.') do |val|
        vals.interactive_post = val.split(',').map { |phase| phase.strip.to_sym }
      end

      opts.on('-f FLAGS',
              '--flags FLAGS',
              String,
              'Comma-separated list of name:value pairs') do |val|
        # HACK: won't work with flags that have commas in them
        vals.flags = val.split(',').map { |el| el.split(':', 2) }.to_h
      end

      opts.on('-r', '--review', 'Pause after automation completes') do
        vals.review = true
      end

      opts.on('-h', '--help', 'Prints this help message') do
        puts opts
        exit
      end
    end.parse!(flags)

    vals
  end

  # returns true if the options are valid.
  def _validate_options?
    raise StandardError, 'Automation not specified!' unless @options.automation_path
    @options.interactive_post = [] unless @options.interactive_post.is_a?(Array)
    @options.interactive_before = [] unless @options.interactive_before.is_a?(Array)
    @options.flags = {} unless @options.flags.is_a?(Hash)
    true
  end

  # Look for a conventional directory to add to the load path. This runner
  # assumes a directory structure in which all automations are located under a
  # single directory with a conventional name at the root of another directory
  # that contains all other files required for the automation to run.
  # Specifically, it is looking for a directory with the following structure:
  #
  # <project_dir>/ (this is what gets added to the load path)
  #   AUTOMATION_DIR_BASENAME/
  #     ... (the automation being run is somewhere in here)
  #   ... (any other directories and files)
  #
  # If found, the directory is added to the load path.
  def _include_load_path
    automation_absolute_path = File.expand_path(@options.automation_path)

    Pathname.new(automation_absolute_path).ascend do |path|
      if path.basename.to_s.eql?(AUTOMATION_DIR_BASENAME)
        $LOAD_PATH.unshift(path.dirname.to_s)
        break
      end
    end
  end

  def _load_automation_source
    require_relative File.expand_path(@options.automation_path, Dir.pwd) # load that path
  end

  def _select_automation_class
    # Attempt to load the specified class, if provided
    return Object.const_get(@options.automation_class_name) if @options.automation_class_name

    # Detect all Automation subclasses
    detected_automations = ObjectSpace.each_object(Ladon::Automator::Automation.singleton_class)

    # Filter to only those Automation subclasses that are marked executable
    executable_automations = detected_automations.select { |cls| cls.respond_to?(:abstract?) && !cls.abstract? }

    # Select a single executable Automation subclass to run
    raise StandardError, 'No non-abstract Automation subclasses detected! Exiting...' if executable_automations.empty?
    return executable_automations[0] if executable_automations.size == 1

    _interactive_class_select(executable_automations)
  end

  def _interactive_class_select(class_options)
    puts "\nPlease select the Automation you wish to run by entering one of the following numbers:"
    class_options.each_with_index { |cls, idx| puts "\t#{idx + 1}. #{cls.name}" }
    begin
      idx = gets.to_i
      raise StandardError unless idx > 0 && idx < class_options.size
      return class_options[idx]
    rescue
      puts 'Nope. Try again.'
      retry
    end
  end

  def _print_separator_line(sep = '*')
    puts sep.to_s * 80
  end
end

flags = Hash[LadonAutomationRunner::ARGV_FLAG, ARGV]
runner = LadonAutomationRunner.spawn(flags: Ladon::Flags.new(in_hash: flags))
runner.run

puts 'ladon-run complete!'
